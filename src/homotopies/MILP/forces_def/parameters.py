from dataclasses import dataclass
from enum import IntEnum
import numpy as np
from dg_commons.sim.models.vehicle_utils import VehicleParameters
from dg_commons.sim.models.vehicle_structures import VehicleGeometry

from .indices import IdxState, IdxInputB, IdxInputC, IdxSlack


@dataclass(frozen=True)
class CarParams:
    vehicle_params = VehicleParameters.default_car()
    vehicle_geometry = VehicleGeometry.default_car()
    N: int = 10
    """ # of stages in the prediction horizon """
    dt: float = 0.3
    """ step length in seconds """
    x_idx: IntEnum = IdxState
    ub_idx: IntEnum = IdxInputB
    uc_idx: IntEnum = IdxInputC
    s_idx: IntEnum = IdxSlack
    n_states: int = len([s.value for s in IdxState])
    n_binputs: int = len([u.value for u in IdxInputB])
    n_cinputs: int = len([u.value for u in IdxInputC])
    n_slacks: int = len([u.value for u in IdxSlack])
    n_ineq: int = 10  # number of inequality constraints generated by each intersection(2 for homotopy, 8 for binary variables)
    C: np.ndarray = np.array([[0, 1, dt],  # discretized dynamics C=[B,A], x_i+1 = Ax_i + Bu_i
                              [dt, 0, 1]])
    s_reward = 1  # reward to the progress along ref-path
    penalty_input = 1  # quadratic penalty on input
    M: int = 1000  # M in big-M formulation


params = CarParams()
x_idx = params.x_idx
ub_idx = params.ub_idx
uc_idx = params.uc_idx
player_idx = {'p1': 0, 'p2': 1, 'p3': 2}
inter_idx = {('p1', 'p2'): 0, ('p1', 'p3'): 1, ('p2', 'p3'): 2}
