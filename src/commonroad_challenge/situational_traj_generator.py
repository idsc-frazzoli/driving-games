from typing import FrozenSet

from decimal import Decimal as D

import numpy as np
from random import sample
from commonroad.common.solution import VehicleType, vehicle_parameters
from commonroad.scenario.trajectory import Trajectory
from commonroad_dc.feasibility import feasibility_checker
from commonroad_dc.feasibility.vehicle_dynamics import VehicleDynamics

from commonroad_challenge.utils import convert_to_cr_state
from dg_commons import Timestamp, PlayerName
from dg_commons.planning import RefLaneGoal
from dg_commons.planning import Trajectory as Dg_Trajectory

from dg_commons.sim.models import extract_pose_from_state, CAR
from dg_commons.sim.models.vehicle import VehicleState
from dg_commons.sim.models.vehicle_structures import VehicleGeometry
from trajectory_games import TrajectoryGenParams


def feasibility_check(traj: Dg_Trajectory, vehicle_dynamics: VehicleDynamics, dt: Timestamp) -> bool:
    cr_traj_states = []
    values = traj.values
    for i, state in enumerate(values):
        current_state = convert_to_cr_state(state)
        current_state.time_step = i
        cr_traj_states.append(current_state)
    cr_traj = Trajectory(initial_time_step=0, state_list=cr_traj_states)
    # check feasibility of planned trajectory for the given vehicle model and dynamics
    feasible, _ = feasibility_checker.trajectory_feasibility(cr_traj, vehicle_dynamics, dt)
    return feasible


class SituationalTrajectoryGenerator:
    """
    This class analyzes a situation in an interactive commonroad scenario and computes suitable parameters
    for a trajectory generator.
    Furthermore, it filters actions generated by the trajectory generator.
    Each player has its own SituationalTrajectoryGenerator
    """

    def __init__(self, ref_lane_goal: RefLaneGoal):
        self.ref_lane_goal: RefLaneGoal = ref_lane_goal
        self.vehicle_type = VehicleType.FORD_ESCORT

    def get_traj_gen_params(self, state: VehicleState, time_to_goal: Timestamp, is_ego: bool) -> TrajectoryGenParams:
        """
        From a specific situation, i.e. current state and reference lane + goal, return suitable parameters for
        the trajectory generator
        :return:
        """

        cr_vehicle_params = vehicle_parameters[self.vehicle_type]

        # todo: remove is_ego, only for development
        if is_ego:
            pose = extract_pose_from_state(state)
            ref_lane = self.ref_lane_goal.ref_lane
            goal_progress = self.ref_lane_goal.goal_progress
            avg_dist_to_goal = goal_progress - ref_lane.lane_pose_from_SE2_generic(pose).along_lane

            # find a that reaches goal by approximating by linear motion with constant acceleration
            acc_mean = 2.0 * (avg_dist_to_goal - state.vx * time_to_goal) / time_to_goal ** 2
            acc_max = abs(acc_mean)

            # always allow more braking than accelerating
            u_acc = frozenset(np.linspace(-abs(acc_mean)*4.0 + acc_mean, acc_mean + abs(acc_mean), num=3, endpoint=True))
            u_dst = frozenset(np.array([-0.15, 0, 0.15])) # be careful when removing u_dst=0.0 -> issue with friction circle!
            # todo: if vehicle is oriented along straight street, leave out dst!!

        else:
            u_acc = frozenset(np.array([0.0]))
            u_dst = frozenset(np.array([0.0]))

        vg = VehicleGeometry(
            vehicle_type=CAR,
            m=1500.0,
            Iz=1300,
            w_half=cr_vehicle_params.w / 2.0,
            lf=cr_vehicle_params.a,
            lr=cr_vehicle_params.b,
            c_drag=0.3756,
            a_drag=2,
            e=0.5,
            color="royalblue",
        )

        return TrajectoryGenParams(
            solve=False,
            s_final=-1,
            max_gen=4,
            dt=D("1.0"),
            u_acc=u_acc,
            u_dst=u_dst,
            v_max=cr_vehicle_params.longitudinal.v_max,
            v_min=0.0,  # don't allow driving backwards
            v_switch=cr_vehicle_params.longitudinal.v_switch,
            acc_max=cr_vehicle_params.longitudinal.a_max,
            st_max=cr_vehicle_params.steering.max,
            dst_max=cr_vehicle_params.steering.v_max,
            dt_samp=D("0.1"),
            dst_scale=False,
            n_factor=1.0,
            vg=vg
        )

    def filter_actions(self, trajectories: FrozenSet[Dg_Trajectory], n_actions: int = 10) \
            -> FrozenSet[Dg_Trajectory]:
        """
        Filter actions through a set of criteria, e.g. feasibility
        :return:
        """
        vehicle_dynamics = VehicleDynamics.KS(self.vehicle_type)

        subset_trajs = set()
        remaining_trajs = set(trajectories)

        while len(subset_trajs) < n_actions or len(remaining_trajs) == 0:
            cand_traj = sample(remaining_trajs, 1)[0]
            dt = cand_traj.timestamps[1] - cand_traj.timestamps[0]
            remaining_trajs.remove(cand_traj)
            feasible = feasibility_check(cand_traj, vehicle_dynamics, dt)
            if feasible:
                subset_trajs.add(cand_traj)

        return frozenset(subset_trajs)

    def add_actions(self):
        """
        Here add emergency braking
        :return:
        """
        pass

    def generate_actions(self, state: VehicleState, time_to_goal: Timestamp) -> FrozenSet[Dg_Trajectory]:
        # todo: for now generate actions in original trajectory generator

        pass
